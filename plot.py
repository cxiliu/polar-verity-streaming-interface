'''
Visualise in real-time the PPG, ACC and HR data from the sensors. The data is read from the files generated by the stream.py script.

Usage: python plot.py -id 1 -window 20
- id: recording id
- window: moving window size in seconds
'''

import matplotlib.pyplot as plt
import matplotlib.animation as animation
import neurokit2 as nk
from statistics import mean 
from datetime import datetime
from process_data import get_ppg_raw, get_acc_raw, get_hr_raw
import time
from termcolor import colored


RECORD_ID = 1 
WINDOW = 20 
BUFFER_SIZE_PPG = 55 * WINDOW # moving window
BUFFER_SIZE_ACC = 52 * WINDOW # moving window
BUFFER_SIZE_HR = 1 * WINDOW

SHOW_GRAPHIC = True
PRINT_DEBUG = False

CLAMP_Y = False
PPG_RANGE = (-30000, 30000)
ACC_RANGE = (-10, 30)
HR_RANGE = (50, 140)

LINE_COUNT = 0

start_us =datetime(2024, 2, 1, 0, 0).timestamp() * 1000000

last_t = time.time()
last_hrv = -1
last_hrv_freq = -1
last_hr = -1


def animate(i):
    t = time.time()
    global last_hrv
    global last_hrv_freq
    global last_hr
    global last_t
    global LINE_COUNT

    try:
        results_hr = get_hr_raw(f"data/{RECORD_ID}-hr.txt")
        if not results_hr:
            print ("skip: no hr data")
            return
    except Exception as e:
        print ("skip: error reading hr data")
        return
    results_ppg = get_ppg_raw(f"data/{RECORD_ID}-ppg.txt", tail = BUFFER_SIZE_PPG)
    if not results_ppg: return
    results_acc = get_acc_raw(f"data/{RECORD_ID}-acc.txt", tail = BUFFER_SIZE_ACC)
    if not results_acc: return
    
    # skip the loop unless there is new data
    if len(results_hr[0]) == LINE_COUNT:
        return
    LINE_COUNT = len(results_hr[0])


    '''
    Show Heart Rate
    '''

    ax3.clear()
    hrs, ts = results_hr
    hrs = hrs[:-BUFFER_SIZE_HR] if len(hrs) > BUFFER_SIZE_HR else hrs
    ts = ts[:-BUFFER_SIZE_HR] if len(ts) > BUFFER_SIZE_HR else ts

    clamp_x_high = ts[-1]
    clamp_x_low = ts[0]
    
    avg_hr = int(mean(hrs))
    if avg_hr != 0:
        last_hr = avg_hr
        if PRINT_DEBUG: print (colored(f"updated with hr {avg_hr}", 'yellow'))
    else:
        print (colored("filling with last hr", 'blue'))
    if SHOW_GRAPHIC:
        ax3.title.set_text(f'HR_Mean: {avg_hr}')
        ax3.plot(ts, hrs, label = "HR")
        if CLAMP_Y: ax3.set_ylim(HR_RANGE[0], HR_RANGE[1])
        # ax3.set_xlim(clamp_x_low, clamp_x_high)
        ax3.legend(loc="upper left")



    '''
    Process PPG
    Each channel represents: green, red and infrared light transmitted to the skin tissue and the data is captured by its receptor.
    '''
    ppg0s, ts = results_ppg
    # The normal frequency range for PPG signals is 0.5 to 5 Hz, while for motion artifacts it is 0.01 to 10 Hz
    filtered = nk.signal_filter(ppg0s, sampling_rate = 55, lowcut = 0.5, highcut = 5, method = "butterworth", order = 2)
    ppg_clean = nk.ppg_clean(filtered, method = "elgendi", sampling_rate = 55)
    ax1.clear()

    if SHOW_GRAPHIC: 
        # ax1.plot(ts, ppg0s, label="PPG0", zorder=1)
        # ax1.plot(ts, filtered, label="FILTERED", zorder=0)
        ax1.plot(ts, ppg_clean, label="CLEAN", zorder=1)
        if CLAMP_Y: ax1.set_ylim(PPG_RANGE[0], PPG_RANGE[1])
        # ax1.set_xlim(clamp_x_low, clamp_x_high)
        ax1.legend(loc="upper left")



    '''
    Process ACC
    '''
    accs, ts = results_acc
    avg_acc = int(mean(accs))
    if PRINT_DEBUG: print (colored(f"updated with acc {avg_acc}", 'yellow'))
    ax2.clear()
    if SHOW_GRAPHIC:
        ax2.title.set_text(f'Mean: {avg_acc}')
        accs = nk.signal_filter(accs, sampling_rate = 52, lowcut = 0.1, highcut = 3, method = "butterworth", order = 2)
        ax2.plot(ts, accs, label = "ACC")
        if CLAMP_Y: ax2.set_ylim(ACC_RANGE[0], ACC_RANGE[1])
        # ax2.set_xlim(clamp_x_low, clamp_x_high)
        ax2.legend(loc="upper left")

    if SHOW_GRAPHIC: fig.suptitle(f'Real-time PPG + ACC + HR, Window: {int((clamp_x_high - clamp_x_low)/1000000)} seconds')

    print (colored(f"Update finished in: {(time.time() - t):.2f} seconds with t_delta: {(last_t-t):.2f}", 'green'))
    last_t = t




if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('-id', type=int, default=1, help='recording id')
    parser.add_argument('-window', type=int, default=20, help='plotting moving window size in seconds')
    args = parser.parse_args()
    RECORD_ID = args.id
    WINDOW = args.window
    if WINDOW < 20:
        print (colored("Warning: window size is too small for frequency-domain analysis. Pick a number >= 20. ", 'red'))
        exit()
    BUFFER_SIZE_PPG = 55 * WINDOW 
    BUFFER_SIZE_ACC = 52 * WINDOW 
    print (f"Plotting data for id {RECORD_ID} with window {WINDOW}... ")

    fig, (ax1, ax2, ax3) = plt.subplots(3, 1)
    fig.suptitle('Real-time PPG + ACC + HR')
    anim = animation.FuncAnimation(fig, animate, interval=500, save_count=1000)
    anim_running = True
    def onClick(event):
        global anim_running
        print (f"Clicked at {event.x}, {event.y}")
        if anim_running:
            fig.suptitle('Real-time PPG + ACC + HR (paused)')
            anim.event_source.stop()
            anim_running = False
        else:
            fig.suptitle('Real-time PPG + ACC + HR (running)')
            anim.event_source.start()
            anim_running = True
    
    fig.canvas.mpl_connect('button_press_event', onClick)
    # animate(0)
    plt.subplots_adjust(hspace=0.3)
    plt.show()
